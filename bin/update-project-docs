#!/usr/bin/env bash

#### name: update-project-docs
#### date: 06.19.2019
#### dependencies: `tree`, `sed`

#### NOTES: use after syncing other files, directories etc. to a project in an alias, then add github workflow after running the script in the same alias. written for bash. minor edits required for posix. [[namely]]. EXAMPLE: <ALIAS>="rsync <files><dirs> <path> && cd <path> && <run-this-script> && git add . && git commit -v && git push"

#### DESCRIPTION: 1. If README and CHANGELOG do not exist: Prompts to create the files at the root directory and formats new files for updating via script. 2. Once the files exist: Auto updates (within set markers) the README with current tree view (of reasonable depth) and timestamp / info. 3. Opens editor to add entries to the CHANGELOG and applies them with timestamp / info.

update_project_docs() {

  # Ansi colors.
  local red=$'\e[1;31m'
  local grn=$'\e[1;32m'
  local end=$'\e[0m'

  # For tests and messages
  local README='README.md'
  local CHANGELOG='CHANGELOG.md'
  local PACKAGE_JSON='package.json'
  local not_found="${red}not found.${end}"
  local is_found="${grn}is found.${grn}"
  local create_prompt="${grn}Create File?${end} [Y/n]: "
  local update_prompt="${grn}Update File?${end} [Y/n]: "
  local ready_msg="Ready. ${red}C${end} to Cancel or ${grn}Any${end} to continue. "
  local exit_msg="${red}Cancelled.${end}"

  # For formatting
  local temporary_text_file='temporary_text_file.txt'
  local temporary_package_file='temporary_package_file.txt'
  local triple_ticks="\`\`\`"

  # Function to update the tree in README

  update_tree() {

    local time_stamp
    time_stamp="Last Tree Update: $(date)"

    local tree_output
    tree_output=$(tree -Ia "node*|.git|old|tMp|.cache|d|20*")

    sed -n -i '1,/##### tree/p;/##### notes/,$p' $README
    {
      echo "$triple_ticks"
      echo "$tree_output"
      echo "$time_stamp"
      echo -e "$triple_ticks\n"
    } >> $temporary_text_file

    sed -i "/##### tree/r $temporary_text_file" "$README"

    rm $temporary_text_file

  }

  # Logic If README exists: prompt to update, then if call update.
  if [[ -f $README ]]; then
    read -r -p "${README} ${is_found} ${update_prompt}" answer_one_b
    if [ "$answer_one_b" = "Y" ] || [ "$answer_one_b" = "y" ]; then
      update_tree
      echo "Tree Successfully Updated..."
    fi
  fi

  # Logic if README does NOT exist: prompt to create --> then formats, ELSE: exits.
  if [[ ! -f $README ]]; then
    echo
    read -r -p "${README} ${not_found} ${create_prompt}" answer_one

    if [ "$answer_one" = "Y" ] || [ "$answer_one" = "y" ]; then
      touch $README && echo -e "\n${README} ${grn}created.${end}"

      # NOTE: README markers are set here.
      {
        echo -e "##### tree\n"
        echo -e '##### notes'
      } >> "$README"

    else
      echo -e "\n${README} does not exist. ${exit_msg}\n"  && exit 1
    fi
  fi

  # IF no CHANGELOG: prompt to create --> then formats, ELSE: exits.
  if [[ ! -f $CHANGELOG ]]; then
    echo
    read -r -p "${CHANGELOG} ${not_found} ${create_prompt}" answer_two

    if [ "$answer_two" = "Y" ] || [ "$answer_two" = "y" ]; then
      touch $CHANGELOG && echo -e "\n${CHANGELOG} ${grn}created.${end}"
      # NOTE: CHANGELOG marker set here.
      echo -e '##### changelog\n' >> "$CHANGELOG"
    else
      echo -e "\n${CHANGELOG} does not exist. ${exit_msg}\n" && exit 1
    fi

  fi

  # Prompt to start next step or cancel.
  echo
  read -r -p "$ready_msg" answer_three

  if [[ "$answer_three" = "C" ]]; then
    echo
    echo -e "${exit_msg}" && exit 0
    echo
  fi


  update_packages() {

    if [[ ! -f $PACKAGE_JSON ]]; then
      echo "no package.json file exists"
    else
      {
        echo '##### packages';
        echo "$triple_ticks";
        jq '.dependencies' package.json
        jq '.devDependencies' package.json
        # cat ./package.json | jq .devDependencies
        # cat ./package.json | jq .dependencies
        echo "$triple_ticks"
        echo -e "\nLast package.json Update: $(date)"
      } >> $temporary_package_file
    fi

  }

# 1. Update tree first.
# update_tree
# 2. Update packages second.
# update_packages


}

update_project_docs
